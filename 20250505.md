# 競プロにおける合同式での除算のやり方まとめ

何回か調べたのですが「で結局どうすればいいの？」と疑問を抱いたり、他の人が知らない方法で割り算してたりしてたので、ここにまるっと方法をまとめます。

より数学的に厳密な証明方法は他に探せばいくらでもあるのでそちらに譲ります。
ここではあくまで競プロでサクッと合同式における割り算をしたい方向けの説明に特化します。

## 前提

- 合同式において、除算以外の四則演算は普通の四則演算と同じように計算して良いです。
  - 普通に足し算/引き算/掛け算して良いということ
- $$a$$の逆元とは、$$a$$にかけると1になるような何かのこと。
  - 普通の四則演算において、2の逆元は$$\frac{1}{2}$$、4の逆元は$$\frac{1}{4}$$
- $$a$$で割るというのは、$$a$$の逆元をかけるのと同じ
  - 上記普通の四則演算を見ると、$$2 \div 2 = 2 \times \frac{1}{2}$$となることからわかる
- そのため、$$a$$で割るというのは、$$a$$の逆元を求めてそれを掛けるのと同義

## フェルマーの小定理による方法

フェルマーの小定理とは以下のような定理です。

$$p \text{が素数で、} a \text{と} p \text{が互いに素である時}$$
$$a^{p-1} \equiv 1 \pmod{p}$$

上式より、$$ 1 = a^{p-1} = a \times a^{p-2}$$であることがわかります。よって、$$a$$の逆元は$$a ^ {p-2}$$であることがわかります。
例えばpが$$10 ^ {9} + 7$$で与えられていたならば、$$a^{10^9 + 7 - 2}$$を求めて、それを掛けてやれば良いということになります。

ものすごい回数累乗してやる必要があるため、素朴に計算すると非常に低速ですが、2乗の累乗ごとに計算してやることで $$O(\log n)$$ で求めることができます。

以下はこれをビット演算を用いて実装したPythonコードです

```python
def fermat(a, p):
  m = p - 2
  result = 1
  while m > 0:
    if m & 1:
      result = result * a % p
    a = a * a % p
    m >>= 1
  return result
```

## 拡張ユークリッドの互除法による方法

拡張ユークリッドの互除法とは、 $$ a x + b y = gcd(a,b) \text{の倍数} $$ となるような整数解 $$(x,y)$$を求める方法です。ここで$$gcd(a,b)$$とは$$a$$と$$b$$の最大公約数のことです。

今やりたいことは、$$a x \equiv 1$$となるような$$x$$=逆元を求めることでした。
上記合同式はそもそも何を意味しているかと言うと、$$ax \div p = n \ldots 1$$でした。
これは $$ ax - pn = 1$$ と同義です。pnの符号を反転させると$$ ax + pn = 1$$となります。

$$p$$が素数かつ$$0<a<p$$ならば、明らかに$$gcd(a,p)=1$$です。
すると、最初に示した$$ a x + b y = gcd(a,b) \text{の倍数} $$の式と、$$ ax + pn = 1$$が全く一致しているため、この一次不定方程式について解いて$$x$$を求めれば、$$a$$の逆元を求めることができるということになります。

### 求め方

ユークリッドの互除法では、例えば$$96$$と$$21$$がある時、次のように計算するのでした。

$$96 \div 21 = 4 \ldots 12$$
$$21 \div 12 = 1 \ldots 9$$
$$12 \div 9 = 1 \ldots 3$$
$$9 \div 3 = 0$$
$$\therefore gcd(96,21) = 3$$

拡張ユークリッドの互除法の操作はこれに酷似します。
証明をすっ飛ばした具体的なやり方は以下の通りです。

$$96x + 21y = gcd(96,21) = 3 \text{となる} (x,y) \text{を求めたい}$$
$$96x + 21y = 3$$
$$21x + 12y = 3$$
$$12x + 9y = 3$$
$$9x + 3y = 3$$
$$3x + 0y = 3$$
$$3x + 0y = 3$$ において、$$(x,y)=(1,0)$$は明らかに正しい。
この解から、以下のようにして等式を遡る
$$3x + 0y = 3 \Rightarrow(x,y) = (1,0)$$
$$9x + 3y = 3$$の$$x$$に上記解の$$y$$の値を代入する。
$$9 \cdot 0 + 3y = 3$$
$$3y = 3 \Rightarrow (x,y) = (0,1)$$
この操作を $$96x + 21y = 3$$まで繰り返す
$$12 \cdot 1 + 9y = 3 \Rightarrow (x,y) = (1, -1)$$
$$21 \cdot (-1) + 12y = 3 \Rightarrow (x,y) = (-1, 2)$$
$$96 \cdot 2 + 21y = 3 \Rightarrow (x,y) = (2, -9)$$
以上より、$$96x + 21y = 3$$の解は$$(x,y) = (2, -9)$$

法を$$10 ^ 9 + 7$$とした時の、$$a$$の逆元を求めたいとなれば、上記方法を用いて、$$ax + (10 ^ 9 + 7)y = gcd(a,10 ^ 9 + 7) = 1$$における$$x$$を求めれば良いです。

以下、簡単な証明を付記します。

$$ax + by = d$$が成り立つ時、$$a = qb + r$$と置き換えると、
$$(qb + r)x + by = d$$
変形して、 $$b(qx + y) + rx = d$$
$$ax + by = d$$の$$(a,b,d)$$に、$$(96,21,3)$$を代入してみると、$$b(qx + y) + rx = d$$というのは、$$21(qx + y) + 12x = 3$$となります。
$$(qx+y) = x', x = y'$$とおいて、$$21x' + 12y' = 3$$となるような$$(x',y')$$を求めれば、$$96x + 21y = 3$$について、$$(x', y') = (qx + y, x)$$より、$$(x,y)$$も求められます。
となると、この式操作を繰り返した結果、$$(x,y)$$が簡単に求まるような式にたどり着けるなら、この式を逆順に辿ることで$$ax + by = d$$も求まることになります。

具体例においては$$3x + 0y = 3$$まで持っていけましたが、常にこうした簡単な式にたどり着けるのでしょうか？
$$ax + by = d$$を$$b(qx + y) + rx = d$$に変形するのは、ユークリッドの互除法による最大公約数を求める操作そのものです。
なので、この操作を再帰的に繰り返せば、やがて$$gcd(a,b)x + 0y = d$$の形にたどり着きます。
上記式は、もし$$d = \gcd(a, b) \times n \text{nは自然数}$$であれば$$(x, y) = (n, 0)$$と整数解を求められます。

以上より、$$ax + by = d$$について、$$d$$が$$gcd(a,b)$$の倍数であるなら整数解を求められることが証明できました。

以下に再帰によるPythonコードを示します。
Pythonだとデフォルトで再帰できる最大の回数は1000回ですが、拡張ユークリッドの互除法による方法では$$N$$に対して$$\log N$$回の計算で求まります。
なので末尾再帰化しなくてもまず問題にならないでしょう。

```python
# 戻り値のtuple[1]の値がaの逆元になる
# d = gcd(p, a)の倍数であることは所与とする
def euclid(p, a, d):
  if a == 0:
    return (d // p, 0)
  x,y = euclid(a, p % a, d)
  return (y, (d - y * p) // a)
```

## 1～Nを順番に求める方法

$$pが素数で0<a<pの前提で、p = qa + r \text{とおいた時、}$$ $$r$$の逆元 ($$r ^ {-1}$$ と書きます)が分かっていれば、以下のようにして $$a$$の逆元を$$O(1)$$で求めることができます
$$ a \text{の逆元} = -q \cdot r ^{-1}$$
Python的に書くと `p // a * rの逆元`です

これは以下のように証明できます。

$$ q = \frac {p-r} {a} \text{なので}$$
$$-q \cdot r ^{-1}$$
$$= -\frac {p-r} {a} \cdot r ^{-1}$$
$$=- \frac {1}{a} ( p \cdot r ^{-1} - 1 )$$
($$a$$と$$p$$は互いに素なので、法を$$p$$とした合同式における$$\frac {1}{a}$$は存在します)

これに$$a$$をかけてカッコを外すと、
$$ - p \cdot r ^{-1} + 1$$
$$- p \cdot r ^{-1}$$は明らかにpの倍数なので、
$$ - p \cdot r ^{-1} + 1 \equiv 1 \pmod{p}$$
上記より、$$a \times (-q \cdot r ^{-1}) \equiv 1 \pmod{p}$$であるため、$$-q \cdot r ^{-1}$$は$$a$$の逆元です。

「いやいや$$r ^ {-1}$$が分かっていればって言われてもそれ順繰りに求めるんじゃ明らかに$$O(1)$$じゃないじゃん」と思われたかもしれませんが、1から順々に逆元を求めようとするシチュエーションがあります。
組み合わせ$$\mathrm{nCr}$$を求めようとする場合です。

$$\mathrm{nCr} = \frac{n!} {r! (n-r)!}$$ なので、例えば $$\mathrm{10C5}$$を求めようとすると、$$ \frac{10!} {5! (10-5)!} = \frac{10!} {5 \cdot 4 \cdot 3 \cdot 2 \cdot 1 \cdot 5 \cdot 4 \cdot 3 \cdot 2 \cdot 1}$$をする必要があり、5～1の逆元をすべて求める必要があるわけです。

ここで先述の方法を使えば、1から順番に逆元を定数時間で求めていけるため、例えば $$n!$$を求める場合でも $$O(n)$$で計算できます。
フェルマーの小定理及び拡張ユークリッドの互除法の方法で逆元を一つずつ求めた場合は$$O(n \log n) $$かかります。

実装も簡単なので巨大な数の組み合わせの計算をする場合は第一候補となる計算方法です。

```python
def one_to_n(n, p):
  inv = [1] * n
  for i in range(2, n+1):
    # mの逆元がinv[m - 1]に格納されていることに注意
    inv[i - 1] =  (-(p // i) * inv[p % i - 1] + p) % p # +pしないと負値を取りうるため
  return inv
```

## まとめ

フェルマーの小定理、拡張ユークリッドの互除法による方法はよく詳解されていますが、最後に記載した、1からNまで順々に求めていく方法については実際に他の人の回答を見るまで存在を知りませんでした。
合同式において除算をしたい場合、それはしばしば組み合わせの計算であるので、最後に示した方法を丸暗記するのが良いと思います。

実装や理屈が簡単なのはフェルマーの小定理の方でしょうか。
これと先述の方法の2つが分かっていれば困ることはなさそうです。

拡張ユークリッドの互除法は逆元を求める場合以外に、そもそも回答方針として必要になる場合があるのでその意味で覚えておいた方が良いと思います。
